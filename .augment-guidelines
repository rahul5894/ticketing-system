# Augment Guidelines

## 1. Tools & Architecture

- **Modularity:** Write modular code with small, composable functions. Place client-API interactions in dedicated `/services` folders.
- **Separate server/client logic:**
  Use `"use client"` directive explicitly for client files.
  Never call server logic directly from client-side code.

## 2. Response Rules (for AI agents)

1. **No Hallucinations:** If unknown, say “I don’t know.”
2. **Be Specific:** Avoid vague answers to specific queries.
3. **Analyze Mistakes:** Investigate actual code/actions, identify errors with examples.
4. **Code First:** Always check code before making claims.
5. **Express Uncertainty:** State when uncertain, verify using tools, and explain your process.
6. **No Assumptions:** Don’t assume project details, user preferences, or configs.
7. **Verify Assumptions:** Pause and verify before proceeding on assumptions.

## 3. Research & Workflow

### Research & Documentation Requirements

1. **Always research latest 2025+ patterns**
   Use Google Research AI to find the most current Next.js, React, TypeScript, and web development best practices when implementing features or solving problems.
2. **Assume some training data is outdated**
   Always cross-check information thoroughly before using it.
3. **Check installed packages**
   Review `package.json` to understand the current tech stack and research relevant 2025+ innovations for each technology.
4. **Use Context7 for documentation**
   Access official docs for all installed libraries/frameworks to ensure use of advanced and recommended patterns.
5. **Stay current with post-2025 innovations**
   Proactively research new techniques, patterns, and tools emerging in 2025 and beyond.

### Workflow Requirements

1. **Sequential Thinking for complex problems**
   Use the sequential thinking tool to break down complex development tasks and plan solutions step-by-step.
2. **Task Management for organization**
   Create detailed task lists with subtasks for all development work to ensure proper tracking and completion.
3. **Proactive tool usage**
   Use research tools whenever encountering:

   - New implementation requirements
   - Performance optimization needs
   - Security considerations
   - Modern pattern adoption opportunities
   - Technology upgrade decisions

### Tool Usage Priority

1. Sequential Thinking — For complex problem solving and planning
2. Google Research AI — For latest patterns, techniques, and 2025+ innovations
3. Context7 — For official documentation and advanced implementation details
4. Task Management — For organizing and tracking all development work

## 4. Codebase Management

1. **Pre-Change:** Retrieve and understand relevant code before changes.
2. **Context Awareness:** Understand dependencies and file relationships before modifications.
3. **Per Change:** Retrieve necessary files, check imports and usage patterns.
4. **File Edits:** View entire file and identify affected elements.
5. **Verify Imports:** Confirm import correctness before submitting.
6. **New Functions:** Check for existing similar functions to avoid duplication.
7. **No Blind Copy:** Understand and adapt any copied code, never blindly paste.

## 5. Servers

1. **No New Servers:** Never run `npm run dev` without killing existing servers.
2. **Check Processes:** Use `list-processes` before restarts.
3. **Restart Existing:** Use exact terminal/process ID to restart.
4. **Restart Steps:** list-processes → kill-process → npm run dev.
5. **No New Ports:** Use existing ports only.

## 6. Core Philosophy

1. **Simplicity:** Write clear, maintainable code. Avoid unnecessary complexity.
2. **Iterate:** Improve working code; rebuild only if needed.
3. **Focus:** Stick to the task. Avoid scope creep.
4. **Quality:** Deliver clean, tested, secure code.
5. **Collaboration:** Work transparently — think, explain, and align.

## 7. Prohibited Practices

1. **No Redirect Hacks:** Follow proper navigation and routing flows. No forced redirects.
2. **No Mock Data in Production:** Use mock data only in test environments.
3. **Use 2025 Standards:** Adhere to modern, secure, scalable methods and keep tools up-to-date.

## 8. Code & UI Standards

1. **Design Smart:** Apply YAGNI, SOLID, KISS, and DRY principles.
2. **Strict Typing:** Use TypeScript strict mode. No `any`. Add JSDoc where helpful.
3. **Keep It Clean:** Write readable, modular code.
4. **Small Files:** Split files larger than 300 lines.
5. **Reuse, Don’t Repeat:** Avoid redundant code.
6. **Optimize Wisely:** Prioritize clean code over premature optimization.
7. **Follow Format:** Use project ESLint + Prettier rules.
8. **Name Clearly:** Use consistent, descriptive names; avoid vague/temp names.
9. **No Throwaway Code:** Don’t commit one-time scripts.
10. **Use ShadCN UI:** Use as default UI library, follow its structure and styling.
11. **Support Dark Mode:** All UI must work in light & dark themes.
12. **Avoid Dead Code:** Remove unused variables, imports, or components as you build.

## 9. Security Rules

1. **Backend First:** Handle sensitive logic server-side.
2. **Validate Input:** Sanitize user input; frontend checks aren’t enough.
3. **Check Dependencies:** Review new libraries for security risks before use.
4. **Protect Secrets:** Use `.env` files. Never expose credentials publicly.

## 10. File Management

1. **Check First:** Avoid duplicates by scanning existing folders before creating new files.
2. **Clean As You Go:** Delete unused files and code during development.
3. **Remove Redundancy:** Clear out obsolete code when adding new logic.

## 11. ESLint Rules

1. No `any` — Use specific or `unknown` types for type safety.
2. No unused variables — Clean up placeholders and unused vars.
3. Always type exported functions’ return types.
4. Avoid redundant types — let TypeScript infer where possible.
5. No `console.log` — Use proper logging tools or remove logs.
6. JSX list keys — Add `key` prop in list renders.
7. Keep hook dependencies accurate (`useEffect`, `useCallback`).
8. No `@ts-ignore` — Fix types instead of silencing errors.
9. No empty functions — Add comments if intentional.
10. No undefined variables — Always import or declare before use.
11. No non-null assertions (`!`) — Check for null before access.
12. Prefer `const` over `let` unless reassignment needed.
13. Use strict equality (`===`) over loose (`==`).
14. No variable shadowing — Avoid reusing names in nested scopes.

## 12. Final Code Validation Before Summary

- **Run ESLint and TypeScript checks** on all newly created or modified files before providing the final summary or submitting code changes.
- **Ensure zero linting and type errors** in all affected files before finalizing any code delivery.
- This step guarantees clean, error-free code that meets project quality standards before review or deployment.

### VS Code Terminal: ESLint & TypeScript Checks

- **Check ESLint errors:**

  ```bash
  npx eslint . --ext .js,.jsx,.ts,.tsx
  ```

- **Check TypeScript errors:**

  ```bash
  npx tsc --noEmit
  ```

## 13. Minimalism & Precision in Code Generation

- **Strict Task Adherence:** The AI should only perform exactly what is requested—no extra files, features, or code beyond the given task.
- **Minimal Necessary Code:** Generate only the code strictly needed to implement the requested functionality—no over-engineering, no unnecessary abstractions or complexity.
- **Modern & Efficient:** Use modern 2025+ best practices and advanced techniques, but always with a minimalist mindset—avoid any code that doesn’t add direct value or isn’t essential.
- **No Extraneous Files:** Avoid creating extra test files, error boundaries, or unrelated utilities unless explicitly requested.
- **Keep It Simple:** Favor straightforward, clear, and maintainable code over fancy or “out-of-the-box” solutions that add bulk or complexity.
- **Minimal Footprint:** The final codebase must have no redundant or unused code, files, or dependencies—only what the application needs to run effectively.

## 14. High Priority: Persistent Task Loop Automation

- Whenever you are about to provide the final summary or close the chat session, you **must run** the script located at `python-cli/loop.py` in the root folder.
- After running this script, wait for the user’s input and follow the instructions accordingly.
- You will repeat running the script and processing new inputs in a continuous loop.
- Continue this loop **without stopping** until the user explicitly sends the command “STOP.”
- Do not terminate or stop this loop on your own.
- This process ensures you remain ready and responsive, never missing any tasks or inputs during final summary or chat closure phases.
